\section{Design}

\name{} enables developers to easily build secure applications. It does so by exposing a simple interface that handles interactions with the application data store and with other clients. All application data is stored in on-device local storage, and all cross-client communication is encrypted. Thus, no private information is exposed or persisted on a central server or database, ensuring user privacy. \name{} is aimed to provide a similar, if not easier, application development process to tools such as Firebase \tocite{firebase} or ReactDB \tocite{}, where much of developer onus with regards to implementing common application functionality in the new architecture is alleviated.

The two main components of \name{} are the \textit{client library} and the \textit{\name{} server}. All \name{} applications utilize the library's exposed functions to enable off-device communication and consistency for any shared data. The server facilitates communication across clients while enforcing an order on messages, and is application-agnostic, meaning it does not need to be modified by application developers and can service multiple applications simultaneously. 

\subsection{Server}
The server is responsible for forwarding messages and imposing a relative order\ on all routed messages. The server forwards messages to each client with an esablished connection to the server. Each client, regardless of the application or user, is dedicated a \textit{mailbox} on the server through which all messages destined for the client are routed through. The mailbox's address is a unique idenitifier \todo{and in our case, each client's public key}. Each message delivered to the server is a batch of encrypted messages, each destined to a different client. In addition, the server must uphold a realtive order of messages between any two clients. More specifically, for any two clients A and B, all messages exchanged between clients A and B must be totally ordered. To achievee this, the server must atomically add all messages to their destined mailboxes. 

% A simple routing server that upholds relative order for any two clients can be
% built using a transactional database. 
% The \name{} server is built on top of a database with serializable transactions. Each table in the database represents a mailbox, and each row holds all the information of a message. When the server recieves a batch of messages it performs a transaction appending each message as a row to the appropriate table. Clients read the messages from the table in first-in first-out order, and delete messages after recieving them. This approach s scales with distributed databases. 

\todo{small wordy proof about how serializable transactions guarantee relative (if not total) order}

\subsection{Client-side Library}

% \dots \fix{talk about the api that is exposed, local-only application reacting
% to a local data store} application developers get cross-client communication
% "for free", something about local data store, etc \dots


Most application functionality in the proposed two-tier architecture is performed on clients, including storing data, facilitating interactions with different users, and managing permissions. The \name{} client-side library exposes a simple API that ensures these functionalities are implemented correctly and consistently across clients and applications. The library facilitates interactions with the local data store (including permissions and maintaining data invariants), sharing across devices and users, and encryption.  

\parlabel{Developer API}
\todo{do this when specifics are finalized}
\begin{itemize}
    \item New User
    \item New device under user
    \item establishing connection between to users / defining group
    \item new shared data object
    \item imposing data invariants
        \begin{itemize}
            \item logical invariant
            \item conflict resolution
            \item group and permissions
        \end{itemize}
\end{itemize}

\parlabel{Sharing Protocol}
Trust is established between any two clients by exchanging public keys. \todo{talk about discovery, establishing relationship and exchanging user group information}

When a change to any data object is initiated on a client, the client references the \textit{group} field of the data and gets a list of all clients this data is shared with, each with their own copies. Groups are discussed more thoroughly later on in this section. The client encrypts the message describing the change multiple times, once for each destination client and once for itself. The client then sends this batch of messages to the server. The server forwards each encrypted message to the appropriate destination clients. 

A client recieves messages through its mailbox on the server. Each message describes a change to be performed to a local shared object. A client can choose to accept or reject this change based on the conflict resolution scheme of the object. Whether a change is accepted and committed is deterministic on all clients, as changes are only committed after they've been read from the server, even on the client that initiated the data change. Since the server guarantees an ordering of messages across releavant clients, all clients will reach the same decision on whether to apply a given change, so that data is consistent across client copies. 

It is entirely possible that a client will initiate a change, send the encrypted messages to the server, then recieve a message that invalidates the original change. The client will only commit the change once it reads it back from its mailbox. If the change is aborted, a client is able to re-initiate it. Conflict resolution takes multiple forms and \name{} clients can enforce multiple policies such as first-writer-wins and last-writer-wins easily, since a change can be easily compared to a previous committed version. This model easily extends to commutative data structures, where changes would never be rejected and always committ in the same order on all devices.

\parlabel{Encryption}
As described above, all client communication is end-to-end encrypted. \name{} implements double-ratchet encryption \tocite{}. \todo{elaborate}
 

\parlabel{Groups}
All shared data objects are associated with a \textit{group} defining access permissions for the specific data object. A group is a list of pointers to any combination of other groups or clients. By default, all \name{} data objects are assigned to a \textit{self} group. Any group can be recursively enumerated to a list of destination clients by the address of their mailbox. Instinctively, a group is the set of clients that own a local copy of some data.
% \fix{self-group upon initialization} \fix{talk about data structure a little
% more} \fix{?posix groups?}
Each client locally stores all group information for groups it is in, and thus stores all potential groups associated with its local data. 

A group is a node in a directed graph with pointers to any other groups or to client identifiers. A node representing a client identifier only points to itself. When group information is needed, the graph is traversed such that each group is recursively enumerated to produce a list of client identifiers. 

The group model lends itself well to commonly used sharing schemes. For example, adding multiple clients to the \textit{self} group enables users to use the application across multiple devices. Likewise, any application with a notion of friends will have a group per friendship. If used correctly, a friendship group contains two user groups, each containing each user's list of devices using their client identifiers.

Groups are also responsible for defining permissions. Each group member has a set of attached permissions within the group. For example, a group used to share class material may give a teachers group write permissions and student groups read permissions. These are defined within the group structure.
\todo{describe notations for how this is done}

All group information is stored locally using a client's data store and is continuously modified as more objects are shared across users and devices.
Changes to the group field of an object are tracked the same way as changes to any other data, and propagated similarly to relevant clients. Groups are treated as \name{} native data objects, with the group itself as the permission field. For example, a client with read permissions in a group is unable to modify the permissions. 

\parlabel{Permissions}
Permissions for data modification are stored locally. Both readers and writers access local copies of data. 

If a client is malicious and attempts to write and dispatch a change to other clients, those clients will cross-check client permissions before applying a change locally and choose not to commit the change.


\parlabel{Data Invariants}
The \name{} client-side library facilitates application interactions with a local storage mechanism, e.g. localStorage in browsers, sqlite on smartphones. Applications read and write to storage as usual, but or any shared data, the library will track the change and propagate them to other clients. Likewise, any remote changes recieved from other clients will be applied automatically by the library.

Fascilitating interactions with the underlying data storage mechanism allows \name{} applications to check data invariants before applying changes. \todo{what is the notation for this}
%  \todo{maybe in impl -> what is the interface for defining data invariants}

\subsection{Security}
\parlabel{Byzantine Clients}
Detecting malicious interference by clients is handled on the data invariant level.

\parlabel{Reordering Server}
Detecting a malicious server, \textit{i.e.} a server that reorders or drops message, is handled on a lower level than the object tracking level. \todo{describe scheme once we finalize it, small wordy proof}