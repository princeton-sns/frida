\section{Security}
\parlabel{Byzantine Clients}
Preventing malicious interference by clients is handled through session rotation as part of the encryption scheme and the on the data invariant level in the validation module. There are multiple attack scenarios protected by our scheme. If a malicious client attempts to connect to a truthful one, the truthful client can simply reject the request for a connection. If two clients already established a trustful relationship, a client turned malicious could be disconnected from others, but users must indicate that themselves if suspicious activity is recognized. If a trusted client attempts to make an unauthorized change, either lacking permissions or attempting to break some invariants, the permissions and invariant checks on all other clients will reject the changes and maintain data integrity.
\todo{what guarantees are we able to provide with the current scheme? forward or backward secrecy? do we just match the guarantees of the encryption scheme?}

\parlabel{Reordering Server}
Detecting a malicious server, \textit{i.e.} a server that reorders or drops message, is handled by the core library. Thus, reordering must be detected based on encrypted payloads- with limited knowledge of the underlying messages or groups.

\noindent 
\fix{LIST OF HASH CHAINS}
% Firstly, assume in this model a group with n clients, where every message sent is sent to everyone in the group.
\todo{no longer entirely sure this particular scheme works, needs some workshopping about what information about other clients you send per message if we do this outside of groups.}

\parlabel{Vector Clocks} Described by Lamport \tocite{lamport}, vector clocks allow systems to detect causality violations between events on multiple processes, or in this case clients. 
To detect reordering using vector clocks, each client maintains a vector of size equal to the number of other clients it interacts with. Each entry of the vector corresponds to a local sequence id of one client, last received over communication channels either directly from that client or indirectly through another client. This vector clock can change in size as communication ends and starts with new clients. Vector clocks always take the max clock value for each other client, ignoring potential holes, i.e. a client can increment another client's clock by more than one. In our scheme, this property would not allow clients to detect if a message was not sent to them or was dropped. Vector clocks alone would discard important information and would not allow a client to detect reordering of concurrent incoming messages originating from different clients. Vector clocks alone are able to validate causal consistency.

\parlabel{Vector Hash Chains}
Instead of version clocks where each event will increment the version by one, we propose using a hash chain to track the state of each client. The head of the hash list will be hashed with an incoming message to form a new node. When sending a message, a client will send the encrypted message and the previous list of hash chains for everyone in the group prior to the event. When a message is received, a client will add a node in the chains of other clients that should've seen the message. If a reordering occurs, clients will be able to detect it by comparing actual and expected hash list heads. Hashes also validate that message content is consistent across clients.

\parlabel{Client-local sequence number}
The previous scheme does not support concurrent operations as only the first operation is supported by a valid hash chain, while any subsequent operations will be discarded. To get around this limitation, each client will also keep track of local sequence ids, and only add a node to its own hash list in the order it was received. This means that a client that is sending a message will only add a node to its hash chain once it receives the message back- allowing concurrent or pending operations to modify the chain in the meantime. 

\parlabel{Varying Number of Connections} To extend this scheme to apply to clients with multiple groups, 
\fix{not sure how much information is leaked if a client shares another client's hash chain, need to think on this a bit more}

\noindent 
\fix{DEPENDENCE GRAPH}
\todo{merge text from mal-server branch}
% We construct an event graph, where a node represents an event and holds information with regards to the event hash, the originating client, and a 

\parlabel{Dependence Graph} \tocite{ken birman Lightweight Causal and Atomic Group
Multicast}
Dependence graphs for multicast operations allow us to validate causal consistency. 
\parlabel{Leaf ordering}
