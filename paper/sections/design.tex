\section{Design}

\name{} enables developers to easily build secure applications. It does so by exposing a simple interface that handles interactions with the application data store and with other clients. All application data is stored in on-device local storage, and all cross-client communication is encrypted. Thus, no private information is exposed or persisted on a central server or database, ensuring user privacy. \name{} is aimed to provide a similar, if not easier, application development process to tools such as Firebase \tocite{firebase} or ReactDB \tocite{}, where much of developer onus with regards to implementing common application functionality in the new architecture is alleviated.

The two main components of \name{} are the \textit{client library} and the \textit{\name{} server}. All \name{} applications utilize the library's exposed functions to enable off-device communication and consistency for any shared data. The server facilitates communication across clients while enforcing an order on messages, and is application-agnostic, meaning it does not need to be modified by application developers and can service multiple applications simultaneously. 

\subsection{Server}
The server is responsible for forwarding messages and imposing ordering on all routed messages. The server forwards messages to each client with an established connection to the server. Each client, regardless of the application or user, is dedicated a \textit{mailbox} on the server containing all messages destined for the client. The mailbox's address is a unique identifier, and in our case, each client's public key. Each message delivered to the server is a batch of encrypted messages, each destined to a different client. Upon receiving a message to be sent, a server must place the message in all destination mailboxes atomically. The server must uphold a relative order of messages between any two clients. More specifically, for any two clients A and B, all messages exchanged between clients A and B must be totally ordered. This constrain forces a total global order on all messages routed through the server. 

% A simple routing server that upholds relative order for any two clients can be
% built using a transactional database. 
% The \name{} server is built on top of a database with serializable transactions. Each table in the database represents a mailbox, and each row holds all the information of a message. When the server receives a batch of messages it performs a transaction appending each message as a row to the appropriate table. Clients read the messages from the table in first-in first-out order, and delete messages after recieving them. This approach s scales with distributed databases. 

\todo{small wordy proof about how serializable transactions guarantee relative (if not total) order}

\subsection{Client-side Library}

% \dots \fix{talk about the api that is exposed, local-only application reacting
% to a local data store} application developers get cross-client communication
% "for free", something about local data store, etc \dots


Most application functionality in the proposed architecture is performed on clients, including storing data, facilitating interactions with different users, and managing permissions. The \name{} client-side library exposes a simple API that ensures these functionalities are implemented correctly and consistently across clients and applications. The library facilitates interactions with the local data store (including checking permissions and maintaining data invariants), sharing across devices and users, and encryption.  

\parlabel{Developer API}
\fix{perhaps move this to implementation section, and show a table of available functions a developer can call.}
The \name{} client-side library exposes an API to application developers. All calls to read and write from the data store or interact with other clients must be done through the \name{} API. When writing a client application, developers will first initiate a \name{} client instance through the library-which will establish communication with the server and assign the client a unique public key as an identifier. Developers will also provide a list of data object types. 
Upon instantiation, the library will write to the data store to initialize needed data structures for the application. Developers then build their applications such that reads and writes for data are executed by using the library's data functions such as \texttt{setData} and \texttt{removeData} which encapsulate data store accesses. The \name{} library will assign data objects unique identifiers. 

A developer can enable sharing across multiple devices by accepting unique identifiers through the application interface and calling the library's \texttt{addContact} function. Adding devices for the same user is just as simple with called to \texttt{addLinkedDevice}. Once a contact relationship is established, data objects can be shared with other devices on a per-object or per-object type basis. A developer can decide default permission schemes per object, or allow an application user to modify them as part of the application. A developer will have to assign a conflict resolution scheme to handle concurrent operations, either from a set of provided schemes including first-writer-win and last-writer-win or write their own and pass them in upon initialization. A developer can also write data validation functions that will be run on relevant interactions with the data store. A developer can write responsive application functions to interact with responses returned by the library indicating uncommitted conflicting changes, impermissible writes, or invalid data modifications.

% All of these functions run complex logic under the hood, translating simple calls to the client library to complex interactions with the local data store and central server over a private communication protocol.


\parlabel{Sharing Protocol}
Trust is established between any two clients by exchanging public keys. Once communication is established, each client adds the other to its contacts list. Only after, a client can share data with the other client. A data object is shared with another user by including the user's identifiers in the data object's \textit{group} field. As part of indicating to the remote client that a new data object was shared with it, the initiating client will send a current copy of the data object so that the client can have a local copy of the data as well.

When a change to any data object is initiated on a client, the client references the group field of the data and gets a list of all clients this data is shared with. Group structure is discussed more thoroughly later on in this section. The client encrypts the message describing the change for all group members and sends it to the server. The server forwards each encrypted message to the appropriate destination clients. 

A client receives messages through its mailbox on the server. Each message describes a change to be performed to a local shared object. A client can choose to accept or reject this change based on the conflict resolution scheme of the object. Whether a change is accepted and committed is deterministic on all clients, as changes are only committed after they've been read from the server, even on the client that initiated the data change. Since the server guarantees an ordering of messages across relevant clients, all clients will reach the same decision on whether to apply a given change based on pre-defined conflict resolution schemes, so that data is consistent across client copies. 

% It is entirely possible that a client will initiate a change, send the encrypted messages to the server, then receive a message that invalidates the original change. The client will only commit the change once it reads it back from its mailbox. If the change is aborted, a client is able to re-initiate it. Conflict resolution takes multiple forms and \name{} clients can enforce multiple policies such as first-writer-wins and last-writer-wins easily, since a change can be easily compared to a previous committed version. This model easily extends to commutative data structures, where changes would never be rejected and always commits in the same order on all devices.

\parlabel{Encryption}
As described above, all client communication is end-to-end encrypted. \name{} implements double-ratchet encryption scheme \cite{signal,matrix}. \todo{elaborate}
 

\parlabel{Groups}
All shared data objects are associated with a \textit{group} defining access permissions for the specific data object. A group is a list of pointers to any combination of other groups or clients. By default, all \name{} data objects are assigned to a \textit{self} group. Any group can be recursively enumerated to a list of destination clients by the address of their mailbox. Instinctively, a group is the set of clients that own a local copy of some data.
% \fix{self-group upon initialization} \fix{talk about data structure a little
% more} \fix{?posix groups?}
% Each client locally stores all group information for groups it is in, and thus stores all potential groups associated with its local data. 

A group is a node in a directed graph with pointers to any other groups or to client identifiers. A node representing a client identifier only points to itself. When group information is needed, the graph is traversed such that each group is recursively enumerated to produce a list of client identifiers. 

The group model lends itself well to commonly used sharing schemes. For example, adding multiple clients to the \textit{self} group enables users to use the application across multiple devices. Likewise, any application with a notion of friends will have a group per friendship. If used correctly, a friendship group contains two user groups, each containing each user's list of devices using their client identifiers.

Groups are also responsible for defining permissions. Each group member has a set of attached permissions within the group. For example, a group used to share class material may give a teachers group write permissions and student groups read permissions. These are defined within the group structure. Groups can be formally defined by a developer or generated by the library based on sharing patterns.

All group information is stored locally using a client's data store and is continuously modified as more objects are shared across users and devices.
Changes to the group field of an object are tracked the same way as changes to any other data, and propagated similarly to relevant clients. Groups are treated as \name{} data objects, with the group itself as the permission field. For example, a client with read permissions in a group is unable to modify the permissions. By default, each group has one admin, responsible for creating the group initially, and must grant write permissions to other clients or groups within the group. Only admins are able to change group permissions.

\parlabel{Permissions}
Permissions for data modification are stored locally. Each group has a list of administrators and writers, where anyone not in those two lists is considered a reader. When a client is either attempting to modify data locally or applying changes sent from a remote client, it checks the permissions list of the object to see whether the client has write permissions on the data object. If not, an invalid permissions error is returned and the change is not applied. 

% If a client is malicious and attempts to write and dispatch a change to other clients, those clients will cross-check client permissions before applying a change locally and choose not to commit the change.


\parlabel{Data Invariants}
The \name{} client-side library facilitates application interactions with a local storage mechanism. Facilitating interactions with the underlying data storage mechanism allows \name{} applications to check data invariants before applying changes. Developers write validation functions for all defined data types, which are dynamically checked when a change is set to be applied locally. After initiating the application, a developer can write and set function per object type. Similarly to permissions, data validation functions are run before any changes to the data store are performed, and if fail do not modify the data.
%  \todo{maybe in impl -> what is the interface for defining data invariants}

\parlabel{Conflict Resolution}
Concurrent operations on data are entirely permissible in this model and must be handled deterministically across all clients. If two clients initiate changes to the same data structure, the server will impose an order on those operations by default. Both clients will then receive the acknowledgement and the new message in some order, and must resolve conflict deterministically based on a pre-set scheme. For example, if a data object follows a first-writer-wins scheme and initiates a data change that then arrives after a different remote change, the initiating client must accept the remote change and abort its proposed change by comparing the before and after values of the change. The client can then attempt to apply the change again, but must treat it as an entirely new data change.

