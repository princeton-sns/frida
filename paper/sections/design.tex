\section{Design}

\name{} enables developers to easily build secure applications. It does
so by exposing a simple interface that handles interactions with the
application data store and with other clients. All application data is 
stored in on-device local storage, and all cross-client communication is
encrypted. Thus, no private information is exposed or persisted on a 
central server or database, ensuring user privacy. \name{} is aimed to provide a similar, if not easier, application development process to tools such as Firebase \tocite{firebase} or ReactDB \tocite{}, where much of developer onus with regards to common application functionality is alleviated.

The two main components of the \name{} architecture are the 
\textit{client library} and the \textit{\name{} server}. All \name{} 
applications utilize the library's exposed functions to enable 
off-device communication and consistency for any shared data. The server
facilitates communication across clients while enforcing a global order 
on messages, and is application-agnostic, meaning it does not need to be 
modified by application developers and service multiple applications 
simultaneously. 

% \fix{firebase, reac

\subsection{Server}
The server is responsible for forwarding messages and imposing a relative 
order on all routed messages. The server forwards messages to each client
with an esablished connection to the server. Each client, regardless of the
application or user, is dedicated a \textit{mailbox} on the server through 
which all messages destined for the client are routed through. The mailbox's
address is a unique idenitifier \todo{and in our case, each client's public
key}. Each message delivered to the server is a batch of encrypted messages,
each destined to a different client. 
In addition, the server must uphold a realtive order of messages between any
two clients. More specifically, for any two clients A and B, all messages 
exchanged between clients A and B must be totally ordered. To achievee this,
the server must atomically add all messages to their destined mailboxes. 

% A simple routing server that upholds relative order for any two clients can
% be built using a transactional database. 
The \name{} server is built on top of a database with serializable 
transactions. Each table in the database represents a mailbox, and each row
holds all the information of a message. When the server recieves a batch of 
messages it performs a transaction appending each message as a row to the 
appropriate table. Clients read the messages from the table in first-in 
first-out order, and delete messages after recieving them. This approach s
scales with distributed databases. 

\todo{small wordy proof about how serializable transactions guarantee relative (if not total) order}


\subsection{Client-side Library}

% \todo{
% \begin{itemize}
%     \item what is the api
%     \item what is simple sharing
%     \item encryption
%     \item groups
%     \item app invariants -> permissions
% \end{itemize}
% }


% \dots \fix{talk about the api that is exposed, local-only application reacting to a local data store} 
% application developers get cross-client communication "for free",
% something about local data store, etc \dots


Most application functionality in the \name{} architecture is performed on 
clients, including storing data, facilitating interactions with different users, 
and managing permissions. The \name{} client-side library exposes a simple API 
that ensures these functionalities are implemented correctly and consistently 
across clients and applications. The library facilitates interactions with the 
local data store (including permissions and maintaining data invariants), 
sharing across devices and users, and encryption.  

\parlabel{Developer API}

\parlabel{Sharing Protocol}
When a change to any data object is initiated on a client, the client references 
the \textit{group} field of the data and gets a list of all clients this data is 
shared with, each with their own copies. Groups are discussed more thoroughly 
later on in this section. The client encrypts the message describing the change 
multiple times, once for each destination client and once for itself. The client 
then sends this batch of messages to the server. The server forwards each 
encrypted message to the appropriate destination clients. 

A client recieves messages through its mailbox on the server. Each message 
describes a change to be performed to a local shared object. A client can choose 
to accept or reject this change based on the conflict resolution scheme of the 
object. Whether a change is accepted and committed is deterministic on all 
clients, as changes are only committed after they've been read from the server, 
even on the client that initiated the data change. Since the server guarantees 
an ordering of messages across releavant clients, all clients will reach the 
same decision on whether to apply a given change, so that data is consistent 
across client copies. 

It is entirely possible that a client will initiate a change, send the encrypted 
messages to the server, then recieve a message that invalidates the original 
change. The client will only commit the change once it reads it back from its 
mailbox. If the change is aborted, a client is able to re-initiate it. Conflict 
resolution takes multiple forms and \name{} can enforce multiple policies such 
as first-writer-wins and last-writer-wins easily, since a change can be easily 
compared to a previous committed version. This model easily extends to 
commutative data structures, where changes would never be rejected and always 
committ in the same order on all devices.

\parlabel{Encryption}
As described above, all client communication is end-to-end encrypted. \name{} 
implements double-ratchet encryption \tocite{}. \todo{elaborate}
 

\parlabel{Groups}
All shared data objects are associated with a \textit{group} defining access 
permissions for the specific data object. A group is a list of pointers to any 
combination of other groups or clients. By default, all \name{} data objects are 
assigned to a \textit{self} group. Any group can be recursively enumerated to a 
list of destination clients by the address of their mailbox. Instinctively, a group is the set of clients that own a local copy of some data.
% \fix{self-group upon initialization}
% \fix{talk about data structure a little more}
% \fix{?posix groups?}
Each client locally stores all group information for groups it is in, and thus 
stores all potential groups associated with its local data. 

A group is a node in a directed graph with pointers to any client identifier that 
is part of that group or to other groups. A node representing a client identifier 
does not point to any other node but itself. When group information is needed, 
the graph is traversed such that each group is recursively enumerated to produce 
a list of client identifiers. 

\todo{user groups}

Changes to the group field of an object are tracked the same way as 
changes to any other object subfield, and propagated similarly to 
relevant clients. Groups are treated as \name{} native data objects,
with the group itself as the permission field.  

\todo{permissions}

\parlabel{Data Invariants}
The \name{} client-side library facilitates application interactions with
a local storage mechanism, e.g. localStorage in browsers, sqlite on 
smartphones. Applications read and write to storage as usual, but or 
any shared data, the library will track the change and propagate them to
other clients. Likewise, any remote changes recieved from other clients
will be applied automatically by the library.

Fascilitating interactions with the underlying data storage mechanism
allows \name{} applications to check data invariants before applying 
changes.
\todo{maybe in impl -> what is the interface for defining data invariants}
 







