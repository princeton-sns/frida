\section{Background and Related Work}

\paragraph{Private messaging.}
Signal \cite{signal} establishes a privacy protocol for instant messaging, in which messages between users are end-to-end encrypted with additional session keys to achieve forward secrecy in the presence of compromised keys. Group information is stored encrypted on the server, but the server is not entirely oblivious to all group information as it "special". The server also knows which devices belong to which users (a kind of group). Signal leverages other specific properties about messaging in their highly-specific protocol, such as weaker consistency needs and simple application invariants (messages should be appended).

Whatsapp \cite{whatsapp}.
Matrix \cite{matrix}.

Stadium \cite{stadium}. \todo{different subsection for different flavor of private messaging.}

\paragraph{Encryption.} \todo{maybe combine with private messaging subsection, although still good to have some separation between encryption and rest of protocol.}
Signal \cite{signal} and Matrix \cite{matrix} both provide a set of end-to-end 
encrypted messaging APIs for private, decentralized communication in an 
asynchronous settings (clients 
can be intermittently offline). Both protocols achieve forward secrecy (where
the confidentiality of older messages is preserved in the face of a compromised
key) 
\todo{and backwards secrecy?}.
\todo{describe these guarantees more.}

They achieve this through the double ratchet algorithm \cite{}, in which
two clients each start with a shared secret key (established through an initial
key-agreement protocol). An initiator client computes the initial shared secret 
key using it's own public/private keys and the public (possibly-signed) key
counterparts of the recipient, and sends an initial message to the recipient
encrypted with the secret key (or some derivation of it). When both the initiator
and recipient are able to compute this shared secret key, a double ratchet session
has started. Then each subsequent message sent using this session is encrypted with
a new key derived from the shared secret key, these keys forming a chain of keys
such that a compromised key somewhere in that chain does not affect the 
confidentiality of messages encrypted with earlier or later keys. \todo{Describe
double ratchet in a bit more detail.} A double
ratchet session exists for every pair of devices \todo{and separately, every
group?}, and all sessions must be appropriately managed. 

An example
of session-management complexity is when the initial message is received by the
recipient but not replied to. A session is technically created on the recipient
but the sender must assume that it was not, because it was never confirmed. 
Therefore, if the sender wants to send another message to the recipient, it must
re-execute the key-agreement algorithm and generate a new session. This process
is repeated until the recipient replies to the sender under one of the sessions.
\todo{more broad session management stuff?}

Differences between the two \todo{need to synthesize this more}:
\begin{enumerate}
\item Signal implements \textit{extended} triple diffie-hellman for it's key agreement
algorithm, which uses slightly different/more keys than Olm's (Matrix's crypto 
lib) implementation of triple diffie-hellman (not extended).
Olm uses one identity key 
and one one-time key per client (where the recipient's 
one-time key is published to the server and obtained by the
initiator). Signal uses one identity key per client, an 
ephemeral key for the initiating client (which does not leave
the client), and a bundle published to the server containing
a signed prekey and a one-time key for the receiving client.
\temp{Signal's one-time key seems to be optional, maybe if high load and the receiving client cannot upload quickly enough, this could help with performance. Have not yet found an actualy explanation this is just my guess.}
All identity keys (in both protocols) are long-term and are published to the server.
\item Olm uses authenticated encryption. Signal does not seem to use authenticated 
encryption, but does require that one of the keys in the pre-key bundle be 
signed. 
\item Signal allows client to either use the secret
key directly to encrypt the first message, or another key
derived from it (via a perfectly-random-function). Olm always encrypts the first
message with a key derived from the secret key (the message key).
\item The contents of the first message are slightly different.
\item When a session is established, Olm generates three additional keys: a root, 
chain, and ratchet key (in addition to the message key). Signal also generates
three keys by different names (\todo{check overlaps in meaning}): a root, 
sender, and receiving chain.
\item Olm supports group messages (encrypted with a single group key) \todo{as
does Signal} figure out the difference. One might be that Signal only supports
group messages via a centralized setting (?) while Olm already does some of that
heavy lifting for us, but \todo{need to confirm}.
\end{enumerate}

\todo{Potential new (but not novel) encryption scheme for group messages.}

The encryption library that Matrix relies on (Olm), implements the double ratchet
algorithm from Signal for pairwise messages, using a slightly different key 
exchange algorithm to bootstrap it. But group messages are where things start to 
diverge. 

In Olm, the group message encryption protocol is called Megolm. Megolm 
communicates group keys from the group creator to all other members of the
group via the aforementioned pairwise encryption scheme. Then the sender
encrypts the first group message (containing more than just keys) with a group
key (determined from a ratchet session similar to that for pairwise encryption).
This improves upon just using pairwise encryption for all members of the group
in situations where the data being communicated is large (and thus the sender
does not need to encrypt it N times, where there are N+1 members in the group).
Furthermore, it saves space on the server for roughly the entirety of time that
it exists there (depending on the implementation).
However, every time sessions are rotated, a new group session key must be 
resent to all other members of the group, which adds two round trips overhead
and server load, whereas rotating sessions in pairwise communication happens
without any extra roung trips.

Signal, on the other hand, (appears to) use pairwise encryption even for
group messages. This maintains a relatively low overhead when most messages are
short strings of text, but quickly grows for documents and media. In such cases, 
an optimization ("Sender Key") is proposed that encrypts the document/media with 
a single, symmetric key, and only sends the symmetric key through the pairwise 
encrypted channels. \todo{confirm} This optimization is roughly used for WhatsApp, 
and in Signal for documents/media. This style of encryption is also used in other
systems like \tocite{pgp} PGP and \todo{find more}.

These approaches delineate several points on the tradeoff spectrum between 
usability and privacy. Megolm group encryption with longstanding sessions is
more usable but less private (if a session key is compromised there are more 
messages that could potentially be leaked). Megolm group encryption with short-
lived sessions is more private but less usable (round trip wait times). Signal
pairwise encryption for group messages is good for privacy (group messages
are indistinguishable from individual ones), but incurs high overhead. The 
Signal optimization has better overhead, but reveals to the server which devices
are in the group because of mailbox access patterns (this also happens in Megolm).
However, since \name{} imposes a total order on events (\todo{at least for now}),
one message going to multiple devices must nevertheless arrive to the server at
the same time (for ordering them as the same event), and thus group membership
at this level is necessarily leaked anyway. This gives \name{} the opportunity
to choose the most efficient encryption mechanism that leaks this amount of 
information, which we believe to be the Sender Key optimization.

\paragraph{Untrusted servers.}
SPORC \cite{sporc} presents a similar application model that primarily leverages the server to establish a global order of events and remaining functionality is handled on the client. However, the SPORC server has a predefined notion of groups and any group modifications are visible to the server, whereas the \name server is completely oblivious to any notion of groups and treats them just like all other data. SPORC also focuses on "operational transform" applications in which operations are meaningful regardless of the order they are applied in. This property is not the case for most applications (and most applications that \name supports), where some operations can be invalidated by others. Furthermore, SPORC does not generalize their application model, although they hint that it could be done, nor does it examine how application invariants could be maintained in the face of malicious or buggy clients. 

SUNDR \cite{sundr}.
Depot \cite{depot}.
Mylar \cite{mylar}.
CryptDB \cite{cryptdb}.

\paragraph{Peer to peer systems.}

Bayou \cite{}.
