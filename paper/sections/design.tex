\section{Design}

\name{} enables developers to easily build secure applications. It does so by exposing a simple interface that handles interactions with the application data store and with other clients. All application data is stored in on-device local storage, and all cross-client communication is encrypted. Thus, no private information is exposed or persisted on a central server or database, ensuring user privacy. \name{} is aimed to provide a similar, if not easier, application development process to tools such as Firebase \tocite{firebase} or ReactDB \tocite{}, where much of developer onus with regards to implementing common application functionality in the new architecture is alleviated.

The two main components of \name{} are the \textit{client library} and the \textit{\name{} server}. The server facilitates communication across clients while enforcing an order on messages, and is application-agnostic, meaning it does not need to be modified by application developers and can service multiple applications simultaneously. The client library is composed of multiple parts, which may be changed depending on application needs. The \name{} core layer handles all off-device communication, encryption, and malicious reordering detection, and operates the same across all devices that obey the \name{} communication protocol. The core library operates on \textit{payloads} which encapsulate changes to the data store by including additional metadata such as timestamps and lists of affected clients. Payloads can be generated locally or received from another client operating on shared data. Payloads can be validated and modified by different \name{} modules between being processed in the core library and changing the data store.

\todo{figure describing client-library layers/architecture} 

\subsection{Server}
The server is responsible for forwarding messages and imposing ordering on all routed messages. The server forwards messages to each client with an established connection to the server. Each client, regardless of the application or user, is dedicated a \textit{mailbox} on the server containing all messages destined for the client. The mailbox's address is a unique identifier, and in our case, each client's public key. Each message delivered to the server is a batch of encrypted messages, each destined to a different client. Upon receiving a message to be sent, a server must place the message in all destination mailboxes atomically. The server must uphold an order of messages between any two clients. More specifically, for any two clients A and B, all messages exchanged between clients A and B must be totally ordered. This constraint forces a total global order on all messages routed through the server. 

\fix{A server uses a central sequencer to order incoming messages. Every epoch, messages are ordered in mailboxes and released to clients.}

\subsection{Core Client-Side library}
The core library enables cross-client communication over encrypted channels. Communication is established between any two clients by establishing a trusted encrypted communication channel, a protocol that depends on the chosen encryption scheme. Client will then exchange all information necessary at this point to establish a contact relationship. For example, to add a secondary device registered to the same user the primary device will transfer all application data to the new device; or to form a connection between two users that each have multiple devices , each user will send the other user's devices a list of all of its devices. 

After a connection is established, the core library will process payloads by encrypting them for each destination client and dispatching the message to the server. 

A client receives messages through its mailbox on the server. Each message payload must be decrypted and interpreted. The core library also receives additional metadata on the message that allows it to check whether messages were potentially reordered on the server. The scheme for detecting reordering is described in further detail in \fix{section 5}. Based on the application, the payload can be processed by modules before directly applying changes to the data store. For example, a module may check whether the client proposing the data change has the correct permissions. 

\parlabel{Double ratchet encryption} The core library integrates with different encryption schemes, including the state-of-the-art double-ratchet protocol. \todo{describe keys, group keys, sessions, etc... anything library must interact with + details not included in background.}


\subsection{Data Store Interface}

The data store API is directly exposed to a developer, which can interact with it as if they are developing a local-only application on top of a local data store. We designed a \name{} key-value data store, which encapsulates an underlying data store to provide a developer with a key-value store-like API. \todo{talk about specific interface}


\subsection{Groups Module}

\todo{
    \begin{itemize}
        \item can add group Id to a data object, enabling sharing
        \item can resolve groupId to a list of dst clients
    \end{itemize}
}

A group is a list any other groups or client identifiers. When a group must be enumerated to a list of destination clients, the top-level group is traversed recursively until the entire list is of client identifiers.

The group model lends itself well to commonly used sharing schemes. For example, adding multiple clients to a \textit{self} group enables users to use the application across multiple devices. Likewise, any application with a notion of friends will have a group per friendship. If used correctly, a friendship group contains two user groups, each containing each user's list of devices using their client identifiers.

The group module is used to ease developer burden when dealing with complex sharing schemes. \todo{figure out exact API for groups and where it's called from. Can be called between storage and core to enumerate list of clients, can be called from validation module to check if client is withina  certain group, etc...}

\subsection{Validation Module}
\parlabel{Permissions}
Permissions for data modification are stored locally. Each data object has a list of groups, each with varying permissions. Developers must pass callbacks that define what operations are allowed for different permissions groups. 


\parlabel{Conflict Resolution}
Concurrent operations on data are entirely permissible in this model and must be handled deterministically across all clients. If two clients initiate changes to the same data structure, the server will impose an order on those operations by default. Both clients will then receive the acknowledgement and the new message in some order, and must resolve conflict deterministically based on a pre-set scheme. For example, if a data object follows a first-writer-wins scheme and initiates a data change that then arrives after a different remote change, the initiating client must accept the remote change and abort its proposed change by comparing the before and after values of the change. The client can then attempt to apply the change again, but must treat it as an entirely new data change.

\parlabel{Invariant Checking}
The \name{} client-side library facilitates application interactions with a local storage mechanism. Facilitating interactions with the underlying data storage mechanism allows \name{} applications to check data invariants before applying changes. Developers write validation functions for all defined data types, which are dynamically checked when a change is set to be applied locally. After initiating the application, a developer can write and set function per object type. Similarly to permissions, data validation functions are run before any changes to the data store are performed, and if fail do not modify the data.


